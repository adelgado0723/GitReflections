<h1 id="lesson-2-reflections">Lesson 2 Reflections</h1>
<h2 id="reflection-1">Reflection 1</h2>
<p><strong>What happens when you initialize a repository? Why do you need to do it?</strong></p>
<p>When you initialize a repository, it begins to be tracked by git. Git stores information about the files in the repository in a hidden folder called .git.</p>
<p>You need to do it because git will not automatically do it for you. Git allows you to choose which files to commit by letting you “stage” them for the commit.</p>
<h2 id="reflection-2">Reflection 2</h2>
<p><strong>How is the staging area different from the working directory and the repository? What value do you think it offers?</strong></p>
<p>The repository is what gets tracked and shared with git. The working directory is where you are making changes to files, and the staging area is where you can choose which changes to commit together.</p>
<p>This allows the user the control of being able to group changes that are logically associated and commit them together.</p>
<h2 id="reflection-3">Reflection 3</h2>
<p><strong>How can you use the staging area to make sure you have one commit per logical change?</strong></p>
<p>You can add and remove changed files from the staging area and tailor the contents of commits to only have files that are logically related.</p>
<h2 id="reflection-4">Reflection 4</h2>
<p><strong>What are some situations when branches would be helpful in keeping your history organized? How would branches help?</strong></p>
<p>Branches can keep your history organized by allowing you to experiment with changes without fear of breaking the working part of the project.</p>
<p>Branches help by providing a space where this experimentation can take place.</p>
<h2 id="reflection-5">Reflection 5</h2>
<p><strong>How do the diagrams help you visualize the brach structure?</strong></p>
<p>The diagrams help me visualize the structure because each node in the graph represents a commit and the edges form the paths that the head can travel.</p>
<h2 id="reflection-6">Reflection 6</h2>
<p><strong>What is the result of merging two branches together? Why do we represent it in the diagram the way that we do?</strong></p>
<p>The result of merging two branches together is a single branch that comtains all the commits of both branches, using parts of each to create a new version of the file or project. Git represents it as two branches coming together and forming a linear commit path. This representations helps me visualize the history of the branches and how they merge.</p>
<h2 id="reflection-7">Reflection 7</h2>
<p><strong>What are the pros and cons of Git’s automatic merging vs. always doing merged manually?</strong></p>
<p>One of the cons of Git’s automatic merging is that it could automatically include code that passes the merging criteria, but you do not want to include in the merge. On the other hand, Git’s automatic merge seems like it will perform the desired operation most of the time and that could save a lot of time.</p>
